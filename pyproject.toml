[project]
name = "legion"
version = "0.1.0"
description = "Legion"
readme = "README.md"
requires-python = ">=3.13"
dependencies = [
    "pyyaml==6.0.2",
    "rich==14.1.0",
]

[dependency-groups]
dev = [
    "isort[colors]==6.0.1",
    "pytest==8.3.3",
    "ruff==0.13.0",
    "yamllint==1.32",
]


[tool.ruff]
fix = false
indent-width = 4
line-length = 120
extend-exclude = [
    "dotbot/**",
]
target-version = "py313"


[tool.ruff.format]
indent-style = "space"
quote-style = "double"
skip-magic-trailing-comma = false


[tool.ruff.lint]
# Enabled rules can be found below. Any rule not mentioned here is not enabled.
# For rules that allow settings/configurations, see the titles after this one.
# Ruff rules can be found at https://docs.astral.sh/ruff/rules
select = [
    # "AIR", #~ Rules for Airflow (need to investigate).
    "ERA001", # Forbids commented out code.
    "YTT", # Rules for use of `sys.version` and `sys.version_info`.
    "ANN001", # Function arguments have type annotations.
    "ANN002", # Check that *args has type annotations.
    "ANN003", # Check that **kwargs has type annotations.
    "ANN201", # Check public functions and methods have annotated return type.
    "ANN202", # Check private functions and methods have annotated return type.
    "ANN204", # Check dunder methods have annotated return type.
    "ANN205", # Check static methods have annotated return type.
    "ANN206", # Check class methods have annotated return type.
    # "S", #~ flake8-bandit (need to investigate).
    "FBT003", # Checks for boolean positional arguments in function calls.
    "B002", # Checks for the attempted use of the unary prefix increment (++) or decrement operator (--).
    "B006", # Checks for uses of mutable objects as function argument defaults.
    "B007", # Checks for unused variables in loops. Intentional ones should be prefixed with `_`.
    "B008", # Checks for function calls in default function arguments.
    "B009", # Checks for uses of getattr that take a constant attribute value as an argument.
    "B010", # Checks for uses of setattr that take a constant attribute value as an argument.
    "B011", # Checks for uses of assert False.
    "B012", # Checks for break, continue, and return statements in finally blocks.
    "B013", # Checks for single-element tuples in exception handlers.
    "B014", # Checks for exception handlers that catch duplicate exceptions.
    "B015", # Checks for useless comparisons.
    "B016", # Checks for raise statements that raise a literal value.
    "B017", # Checks for assertRaises and pytest.raises context managers that catch Exception or BaseException.
    "B018", # Checks for useless expressions.
    "B019", # Checks for uses of the `functools.lru_cache` and `functools.cache` decorators on methods.
    "B020", # Checks for loop control variables that override the loop iterable.
    "B021", # Checks for docstrings that are written via f-strings.
    "B023", # Checks for function definitions that use a loop variable.
    "B024", # Checks for abstract classes without abstract methods or properties.
    "B025", # Checks for try-except blocks with duplicate exception handlers.
    "B026", # Checks for function calls that use star-argument unpacking after providing a keyword argument.
    "B027", # Checks for empty methods in abstract base classes without an abstract decorator.
    "B029", # Checks for exception handlers that catch an empty tuple.
    "B030", # Checks for exception handlers that catch non-exception classes.
    "B031", # Checks for multiple usage of the generator returned from `itertools.groupby()`.
    "B032", # Checks for the unintentional use of type annotations.
    "B033", # Checks for set literals that contain duplicate items.
    "B034", # Checks for calls to `re.sub()`, `re.subn()`, and `re.split()` that pass `count`, `maxsplit`, or `flags` as positional arguments.
    "B035", # Checks for dictionary comprehensions that use a static key.
    # "B909", # Checks for mutations to an iterable during a loop iteration. #> Enable once preview is over.
    "A001", # Checks for variable (and function) assignments that use the same names as builtins.
    "A002", # Checks for function arguments that use the same names as builtins.
    "A003", # Checks for class attributes and methods that use the same names as Python builtins.
    "A004", # Checks for imports that use the same names as builtins.
    "A005", # Checks for modules that use the same names as Python standard-library modules.
    "A006", # Checks for lambda arguments that use the same names as Python builtins.
    "COM812", # Checks for the absence of trailing commas.
    "COM818", # Checks for the presence of trailing commas on bare (unparenthesized) tuples.
    "COM819", # Checks for the presence of prohibited trailing commas.
    "C400", # Checks for unnecessary generators that can be rewritten as list comprehensions (or with `list()` directly).
    "C401", # Checks for unnecessary generators that can be rewritten as set comprehensions (or with `set()` directly).
    "C402", # Checks for unnecessary generators that can be rewritten as dict comprehensions.
    "C403", # Checks for unnecessary list comprehensions.
    "C404", # Checks for unnecessary list comprehensions.
    "C405", # Checks for `set()` calls that take unnecessary list or tuple literals as arguments.
    "C406", # Checks for unnecessary list or tuple literals.
    "C408", # Checks for unnecessary `dict()`, `list()` or `tuple()` calls that can be rewritten as empty literals.
    "C409", # Checks for tuple calls that take unnecessary list or tuple literals as arguments.
    "C410", # Checks for `list()` calls that take unnecessary list or tuple literals as arguments.
    "C411", # Checks for unnecessary `list()` calls around list comprehensions.
    "C413", # Checks for unnecessary `list()` or `reversed()` calls around `sorted()` calls.
    "C414", # Checks for unnecessary `list()`, `reversed()`, `set()`, `sorted()`, and `tuple()` call within `list()`, `set()`, `sorted()`, and `tuple()` calls.
    "C415", # Checks for unnecessary subscript reversal of iterable.
    "C416", # Checks for unnecessary dict, list, and set comprehension.
    "C417", # Checks for unnecessary `map()` calls with lambda functions.
    "C418", # Checks for `dict()` calls that take unnecessary dict literals or dict comprehensions as arguments.
    "C420", # Checks for unnecessary dict comprehension when creating a dictionary from an iterable.
    "DTZ001", # Checks for datetime instantiations that do not specify a timezone.
    "DTZ002", # Checks for usage of `datetime.datetime.today()`.
    "DTZ003", # Checks for usage of `datetime.datetime.utcnow()`.
    "DTZ004", # Checks for usage of `datetime.datetime.utcfromtimestamp()`.
    "DTZ005", # Checks for usages of `datetime.datetime.now()` that do not specify a timezone.
    "DTZ006", # Checks for usage of `datetime.datetime.fromtimestamp()` that do not specify a timezone.
    "DTZ007", # Checks for uses of `datetime.datetime.strptime()` that lead to naive datetime objects.
    "DTZ011", # Checks for usage of `datetime.date.today()`.
    "DTZ012", # Checks for usage of `datetime.date.fromtimestamp()`.
    "DTZ901", # Checks for uses of `datetime.datetime.min` and `datetime.datetime.max`.
    "T100", # Checks for the presence of debugger calls and imports.
    # "DJ", #~ Django rules (need to investigate).
    # "EM", #! I disagree with these error-message rules.
    "EXE001", # Checks for a shebang directive in a file that is not executable.
    "EXE002", # Checks for executable `.py` files that do not have a shebang.
    "EXE003", # Checks for a shebang directive in `.py` files that does not contain `python`, `pytest`, or `uv run`.
    "EXE004", # Checks for whitespace before a shebang directive.
    "EXE005", # Checks for a shebang directive that is not at the beginning of the file.
    # "FIX", #! I disagree with these comment rules.
    "FA", # Rules for `from __future__ import annotations`.
    "INT", # Rules for `gettext` function.
    "ISC001", # Checks for implicitly concatenated strings on a single line.
    "ISC002", # Checks for implicitly concatenated strings that span multiple lines.
    "ISC003", # Checks for string literals that are explicitly concatenated (using the `+` operator).
    # "ICN", #! I disagree with these import rules.
    "LOG", # Rules for loggers.
    "G", # Rules for logger messages.
    # "INP001", #! I disagree with this rule of `__init__.py` files.
    "PIE790", # Checks for unnecessary `pass` statements and ellipsis (...) literals in functions, classes, and other blocks.
    "PIE794", # Checks for duplicate field definitions in classes.
    "PIE796", # Checks for enums that contain duplicate values.
    "PIE800", # Checks for unnecessary dictionary unpacking operators (`**`).
    "PIE804", # Checks for unnecessary `dict` kwargs.
    "PIE807", # Checks for lambdas that can be replaced with the `list` or `dict` builtins.
    "PIE808", # Checks for `range` calls with an unnecessary `start` argument.
    "PIE810", # Checks for `startswith` or `endswith` calls on the same value with different prefixes or suffixes.
    # "T201", #! I disagree with these printing rules.
    "PYI", # Rules for type hinting stub files. #~ I need to investigate more.
    "PT001", # Checks for argument-free `@pytest.fixture()` decorators with parentheses.
    "PT002", # Checks for `pytest.fixture` calls with positional arguments.
    "PT006", # Checks for the type of parameter names passed to `pytest.mark.parametrize`.
    "PT007", # Checks for the type of parameter values passed to `pytest.mark.parametrize`.
    "PT008", # Checks for mocked calls that use a dummy lambda function instead of `return_value`.
    "PT009", # Checks for uses of assertion methods from the unittest module.
    "PT010", # Checks for `pytest.raises` calls without an expected exception.
    "PT011", # Checks for `pytest.raises` calls without a match parameter.
    "PT012", # Checks for `pytest.raises` context managers with multiple statements.
    "PT014", # Checks for duplicate test cases in `pytest.mark.parametrize`.
    "PT015", # Checks for assert statements whose test expression is a falsy value.
    "PT016", # Checks for `pytest.fail` calls without a message.
    "PT017", # Checks for assert statements in except clauses.
    "PT018", # Checks for assertions that combine multiple independent conditions.
    "PT019", # Checks for pytest test functions that should be decorated with `@pytest.mark.usefixtures`.
    "PT020", # Checks for `pytest.yield_fixture` usage.
    "PT021", # Checks for unnecessary `request.addfinalizer` usages in pytest fixtures.
    "PT022", # Checks for unnecessary yield expressions in pytest fixtures. #~ I'm sceptical of this rule. Need to investigate more.
    "PT023", # Checks for argument-free `@pytest.mark.<marker>()` decorators with parentheses.
    "PT024", # Checks for unnecessary `@pytest.mark.asyncio` decorators applied to fixtures.
    "PT025", # Checks for `pytest.mark.usefixtures` decorators applied to pytest fixtures.
    "PT026", # Checks for `@pytest.mark.usefixtures()` decorators that aren't passed any arguments.
    "PT027", # Checks for uses of exception-related assertion methods from the `unittest` module.
    "PT028", # Checks for parameters of test functions with default arguments.
    # "PT029", # Checks for `pytest.warns` calls without an expected warning. #> Enable once preview is over.
    "PT030", # Checks for `pytest.warns` calls without a match parameter.
    "PT031", # Checks for `pytest.warns` context managers with multiple statements.
    "Q000", # Checks for inline strings that use single quotes.
    "Q001", # Checks for multiline strings that use single quotes.
    "Q002", # Checks for docstrings that use single quotes.
    # "Q003", #! Rule does not maintain double quotes as outer ones.
    "Q004", # Checks for strings that include unnecessarily escaped quotes.
    # "RSE102", #! Rule has known issues and it is not very good.
    "RET501", # Checks for the presence of a `return None` statement when `None` is the only possible return value.
    "RET502", # Checks for the presence of a return statement with no explicit value, for functions that return non-None values elsewhere.
    "RET503", # Checks for missing explicit `return` statements at the end of functions that can return non-None values.
    "RET505", # Checks for `else` statements with a `return` statement in the preceding `if` block.
    "RET506", # Checks for `else` statements with a `raise` statement in the preceding `if` block.
    "RET507", # Checks for `else` statements with a `continue` statement in the preceding `if` block.
    "RET508", # Checks for `else` statements with a `break` statement in the preceding `if` block.
    "SLF001", # Checks for accesses on "private" class members.
    "SIM101", # Checks for multiple isinstance calls on the same target.
    "SIM103", # Checks for `if` statements that can be replaced with `bool`.
    "SIM107", # Checks for `return` statements in `try-except` and `finally` blocks.
    "SIM109", # Checks for boolean expressions that contain multiple equality comparisons to the same value.
    "SIM113", # Checks for `for` loops with explicit loop-index variables that can be replaced with `enumerate()`.
    "SIM114", # Checks for `if` branches with identical arm bodies.
    "SIM115", # Checks for cases where files are opened without using a context manager.
    "SIM116", # Checks for three or more consecutive if-statements with direct returns
    "SIM117", # Checks for the unnecessary nesting of multiple consecutive context managers.
    "SIM118", # Checks for key-existence checks against `dict.keys()` calls.
    "SIM201", # Checks for negated `==` operators.
    "SIM202", # Checks for negated `!=` operators.
    "SIM208", # Checks for double negations.
    "SIM212", # Checks for `if` expressions that check against a negated condition.
    "SIM220", # Checks for `and` expressions that include both an expression and its negation.
    "SIM221", # Checks for `or` expressions that include both an expression and its negation.
    "SIM222", # Checks for `or` expressions that contain truthy values.
    "SIM223", # Checks for `and` expressions that contain falsey values.
    "SIM300", # Checks for Yoda conditions.
    "SIM401", # Checks for `if` statements that can be replaced with `dict.get` calls.
    "SIM905", # Checks for static `str.split` calls that can be replaced with list literals.
    "SIM910", # Checks for `dict.get()` calls that pass `None` as the default value.
    "SIM911", # Checks for use of `zip()` to iterate over keys and values of a dictionary at once.
    "SLOT000", # Checks for subclasses of `str` that lack a `__slots__` definition.
    "SLOT001", # Checks for subclasses of `tuple` that lack a `__slots__` definition.
    "SLOT002", # Checks for subclasses of `collections.namedtuple` or `typing.NamedTuple` that lack a `__slots__` definition.
    "TID251", # Checks for banned imports. See [tool.ruff.lint.flake8-tidy-imports.banned-api] for more information.
    "TID252", # Checks for relative imports.
    "TID253", # Checks for module-level imports that should instead be imported lazily.
    "TD001", # Checks that a TODO comment is labelled with "TODO".
    # "TD002", # All TODOs have authors. Nice to have, but not always applicable.
    # "TD002", # All TODOs links to issues. Nice to have, but not always applicable.
    # "TD004", # All TODOs have colons. #! Nope. I use TODO colorization via a VS Code extension.
    "TD005", # Checks that a "TODO" tag contains a description of the issue following the tag itself.
    "TD006", # Checks that a "TODO" tag is properly capitalized.
    "TD007", # Checks that the colon after a "TODO" tag is followed by a space.
    "TC001", # Checks for first-party imports that are only used for type annotations, but aren't defined in a type-checking block.
    "TC002", # Checks for third-party imports that are only used for type annotations, but aren't defined in a type-checking block.
    "TC003", # Checks for standard library imports that are only used for type annotations, but aren't defined in a type-checking block.
    "TC004", # Checks for imports that are required at runtime but are only defined in type-checking blocks.
    "TC005", # Checks for an empty type-checking block.
    "TC006", # Checks for unquoted type expressions in `typing.cast()` calls.
    "TC007", # Checks if PEP 613 explicit type aliases contain references to symbols that are not available at runtime.
    # "TC008", # Checks for unnecessary quotes in PEP 613 explicit type aliases and PEP 695 type statements. #> Re-evaulate once preview is over.
    "TC010", # Checks for the presence of string literals in `X | Y`-style union types.
    "ARG001", # Checks for the presence of unused arguments in function definitions.
    "ARG002", # Checks for the presence of unused arguments in instance method definitions.
    "ARG003", # Checks for the presence of unused arguments in class method definitions.
    "ARG004", # Checks for the presence of unused arguments in static method definitions.
    "ARG005", # Checks for the presence of unused arguments in lambda expression definitions.
    "PTH100", # Checks for uses of `os.path.abspath`.
    "PTH101", # Checks for uses of `os.chmod`.
    "PTH102", # Checks for uses of `os.mkdir`.
    "PTH103", # Checks for uses of `os.mkdirs`.
    "PTH104", # Checks for uses of `os.rename`.
    "PTH105", # Checks for uses of `os.replace`.
    "PTH106", # Checks for uses of `os.rmdir`.
    "PTH107", # Checks for uses of `os.remove`.
    "PTH108", # Checks for uses of `os.unlink`.
    "PTH109", # Checks for uses of `os.getcwd` and `os.getcwdb`.
    "PTH110", # Checks for uses of `os.path.exists`.
    "PTH111", # Checks for uses of `os.path.expanduser`.
    "PTH112", # Checks for uses of `os.path.isdir`.
    "PTH113", # Checks for uses of `os.path.isfile`.
    "PTH114", # Checks for uses of `os.path.islink`.
    "PTH115", # Checks for uses of `os.path.readlink`.
    "PTH116", # Checks for uses of `os.stat`.
    "PTH117", # Checks for uses of `os.path.isabs`.
    "PTH118", # Checks for uses of `os.path.join`.
    "PTH119", # Checks for uses of `os.path.basename`.
    "PTH120", # Checks for uses of `os.path.dirname`.
    "PTH121", # Checks for uses of `os.path.samefile`.
    "PTH122", # Checks for uses of `os.path.splitext`.
    "PTH123", # Checks for uses of the `open()` builtin.
    "PTH124", # Checks for uses of the `py.path` library.
    "PTH201", # Checks for `pathlib.Path` objects that are initialized with the current directory.
    "PTH202", # Checks for uses of `os.path.getsize`.
    "PTH203", # Checks for uses of `os.path.getatime`.
    "PTH204", # Checks for uses of `os.path.getmtime`.
    "PTH205", # Checks for uses of `os.path.getctime`.
    "PTH206", # Checks for uses of `.split(os.sep)`.
    "PTH207", # Checks for the use of `glob.glob()` and `glob.iglob()`.
    "PTH208", # Checks for uses of `os.listdir`.
    # "PTH210", # Checks for `pathlib.Path.with_suffix()`. #! Disabling because rule is likely to produce false negatives.
    "PTH211", # Checks for uses of `os.symlink`.
    "FLY002", # Checks for `str.join` calls that can be replaced with f-strings.
    "I001", # De-duplicates, groups, and sorts imports based on the provided `isort` settings.
    "I002", # Adds any required imports to the top of the file. See `tool.ruff.lint.isort.required-imports`.
    "C901", # Checks for functions with a high McCabe complexity.
    # "NPY", # Checks for `numpy`. #~ I need to investigate more.
    # "PD", # Checks for `pandas`. #~ I need to investigate more.
    "N801", # Checks for class names that do not follow the `CamelCase` convention.
    "N802", # Checks for functions names that do not follow the `snake_case` naming convention.
    "N803", # Checks for argument names that do not follow the `snake_case` convention.
    "N804", # Checks for class methods that use a name other than `cls` for their first argument.
    "N805", # Checks for instance methods that use a name other than `self` for their first argument.
    "N806", # Checks for the use of non-lowercase variable names in functions.
    "N807", # Checks for functions with "dunder" names that are not documented.
    "N811", # Checks for constant imports that are aliased to non-constant-style names.
    "N812", # Checks for `lowercase` imports that are aliased to non-lowercase names.
    "N813", # Checks for `CamelCase` imports that are aliased to lowercase names.
    "N814", # Checks for `CamelCase` imports that are aliased to constant-style names.
    "N815", # Checks for class variable names that follow the `mixedCase` convention. #~ I'm sceptical of this rule.
    "N816", # Checks for global variable names that follow the `mixedCase` convention.
    "N817", # Checks for `CamelCase` imports that are aliased as acronyms. #~ Python itself already has exceptions to this, e.g. `ABC`.
    "N818", # Checks for custom exception definitions that omit the `Error` suffix.
    "N999", # Checks for module names that do not follow the `snake_case` naming convention or are otherwise invalid.
    "PERF101", # Checks for explicit casts to `list` on for-loop iterables.
    "PERF102", # Checks for uses of `dict.items()` that discard either the key or the value when iterating over the dictionary.
    "PERF203", # Checks for uses of except handling via `try-except` within `for` and `while` loops.
    "PERF401", # Checks for `for` loops that can be replaced by a list comprehension. #~ I'm sceptical of this rule.
    "PERF402", # Checks for `for` loops that can be replaced by a making a copy of a list.
    "PERF403", # Checks for `for` loops that can be replaced by a dictionary comprehension.
    "E101", # Checks for mixed tabs and spaces in indentation.
    "E111", # Checks for indentation with a non-multiple of 4 spaces. #> Requires preview rules to be enabled.
    "E112", # Checks for indented blocks that are lacking indentation. #> Requires preview rules to be enabled.
    "E114", # Checks for indentation of comments with a non-multiple of 4 spaces. #> Requires preview rules to be enabled.
    "E115", # Checks for comments in a code blocks that are lacking indentation. #> Requires preview rules to be enabled.
    "E116", # Checks for unexpected indentation of comment. #> Requires preview rules to be enabled.
    "E117", # Checks for over-indented code. #> Requires preview rules to be enabled.
    "E201", # Checks for the use of extraneous whitespace after "(", "[" or "{". #> Requires preview rules to be enabled.
    "E202", # Checks for the use of extraneous whitespace before ")", "]" or "}". #> Requires preview rules to be enabled.
    "E203", # Checks for the use of extraneous whitespace before ",", ";" or ":". #> Requires preview rules to be enabled.
    "E204", # Checks for trailing whitespace after a decorator's opening `@`. #> Requires preview rules to be enabled.
    "E211", # Checks for extraneous whitespace immediately preceding an open parenthesis or bracket. #> Requires preview rules to be enabled.
    "E221", # Checks for extraneous whitespace before an operator. #> Requires preview rules to be enabled.
    "E222", # Checks for extraneous whitespace after an operator. #> Requires preview rules to be enabled.
    "E223", # Checks for extraneous tabs before an operator. #> Requires preview rules to be enabled.
    "E224", # Checks for extraneous tabs after an operator. #> Requires preview rules to be enabled.
    "E225", # Checks for missing whitespace around all operators. #> Requires preview rules to be enabled.
    "E226", # Checks for missing whitespace arithmetic operators. #> Requires preview rules to be enabled.
    "E227", # Checks for missing whitespace around bitwise and shift operators. #> Requires preview rules to be enabled.
    "E228", # Checks for missing whitespace around the modulo operator. #> Requires preview rules to be enabled.
    "E231", # Checks for missing whitespace after `,`, `;`, and `:`. #> Requires preview rules to be enabled.
    "E241", # Checks for extraneous whitespace after a comma. #> Requires preview rules to be enabled.
    "E242", # Checks for extraneous tabs after a comma. #> Requires preview rules to be enabled.
    # "E251", #! I disagree with this rule.
    "E252", # Checks for missing whitespace around the equals sign in an annotated function keyword parameter. #> Requires preview rules to be enabled.
    # "E261", #! I disagree with this rule.
    # "E262", #! This rule would conflict with the Better comments extension.
    # "E265", #! This rule would conflict with the Better comments extension.
    # "E266", #! This rule would conflict with the Better comments extension.
    "E271", # Checks for extraneous whitespace after keywords. #> Requires preview rules to be enabled.
    "E272", # Checks for extraneous whitespace before keywords. #> Requires preview rules to be enabled.
    "E273", # Checks for extraneous tabs after keywords. #> Requires preview rules to be enabled.
    "E274", # Checks for extraneous tabs before keywords. #> Requires preview rules to be enabled.
    "E275", # Checks for missing whitespace after keywords. #> Requires preview rules to be enabled.
    "E301", # Checks for missing blank lines between methods of a class. #> Requires preview rules to be enabled.
    "E302", # Checks for missing blank lines between top level functions and classes. #> Requires preview rules to be enabled.
    "E303", # Checks for extraneous blank lines. #~ I'm sceptical of this rule.
    "E304", # Checks for extraneous blank line(s) after function decorators. #> Requires preview rules to be enabled.
    "E305", # Checks for missing blank lines after the end of function or class. #> Requires preview rules to be enabled.
    "E306", # Checks for 1 blank line between nested function or class definitions. #> Requires preview rules to be enabled.
    "E401", # Check for multiple imports on one line.
    "E402", # Checks for imports that are not at the top of the file.
    "E501", # Checks for lines that exceed the specified maximum character length. See `tool.ruff.line-length`.
    "E502", # Checks for redundant backslashes between brackets.
    "E701", # Checks for compound statements (multiple statements on the same line).
    "E702", # Checks for multiline statements on one line.
    "E703", # Checks for statements that end with an unnecessary semicolon.
    "E711", # Checks for comparisons to `None` which are not using the `is` operator.
    "E712", # Checks for equality comparisons to boolean literals.
    "E713", # Checks for membership tests using `not element in collection`.
    "E714", # Checks for identity comparisons using `not element is target`.
    "E721", # Checks for object type comparisons using comparison operators. #! WARNING: this rule will produce false positives for `numpy`.
    "E722", # Checks for bare except catches in `try-except` statements.
    "E731", # Checks for lambda expressions which are assigned to a variable.
    "E741", # Checks for the use of the characters `l`, `O`, or `I` as variable names.
    "E742", # Checks for the use of the characters `l`, `O`, or `I` as class names.
    "E743", # Checks for the use of the characters `l`, `O`, or `I` as function names.
    "E902", # This is not a regular diagnostic; instead, it's raised when a file cannot be read from disk.
    "W191", # Checks for indentation that uses tabs.
    "W291", # Checks for superfluous trailing whitespace.
    "W292", # Checks for files missing a new line at the end of the file.
    # "W293", #! Disagree with this rule.
    "W391", # Checks for files with multiple trailing blank lines. #> Requires preview rules to be enabled.
    "W505", # Checks for doc lines that exceed the specified maximum character length.
    "W605", # Checks for invalid escape sequences.
    "DOC201", # Checks for functions with `return` statements that do not have "Returns" sections in their docstrings. #> Requires preview rules to be enabled.
    "DOC202", # Checks for function docstrings with unnecessary "Returns" sections. #> Requires preview rules to be enabled.
    "DOC402", # Checks for functions with `yield` statements that do not have "Yields" sections in their docstrings. #> Requires preview rules to be enabled.
    "DOC501", # Checks for function docstrings that do not document all explicitly raised exceptions. #> Requires preview rules to be enabled.
    "DOC502", # Checks for function docstrings that state that exceptions could be raised even though they are not directly raised in the function body. #> Requires preview rules to be enabled.
    "D100", # Checks for undocumented public module definitions.
    "D101", # Checks for undocumented public class definitions.
    "D102", # Checks for undocumented public method definitions.
    "D103", # Checks for undocumented public function definitions.
    # "D104", #! Disagree with this rule because most "packages" are just an empty `__init__.py` file.
    # "D105", #! Disagree with this rule because dunder methods are standardized methods.
    "D106", # Checks for undocumented public class definitions, for nested classes.
    # "D107", #! Disagree with this rule because dunder methods are standardized methods.
    # "D200", # Checks for single-line docstrings that are broken across multiple lines. #! Disagree with this rule.
    "D201", # Checks for docstrings on functions that are separated by one or more blank lines from the function definition.
    # "D202", # Checks for docstrings on functions that are separated by one or more blank lines from the function body. #! Disagree with this rule.
    # "D203", # Checks for docstrings on class definitions that are not preceded by a blank line. #! Disagree with this rule.
    "D204", # Checks for class methods that are not separated from the class's docstring by a blank line.
    # "D205", # Checks for docstring summary lines that are not separated from the docstring description by one blank line. #! Disagree with this rule.
    "D206", # Checks for docstrings that are indented with tabs.
    "D207", # Checks for under-indented docstrings.
    "D208", # Checks for over-indented docstrings.
    "D209", # Checks for multi-line docstrings whose closing quotes are not on their own line.
    "D210", # Checks for surrounding whitespace in docstrings.
    "D211", # Checks for docstrings on class definitions that are preceded by a blank line.
    # "D212", #! Disagree with this rule.
    "D213", # Checks for docstring summary lines that are not positioned on the second physical line of the docstring.
    "D214", # Checks for over-indented sections in docstrings. #~ I'm sceptical of this rule.
    "D215", # Checks for over-indented section underlines in docstrings.
    "D300", # Checks for docstrings that use triple single quotes instead of triple double quotes.
    "D301", # Checks for docstrings that include backslashes, but are not defined as raw string literals.
    # "D400", #! Disagree with this rule.
    # "D401", #! Disagree with this rule.
    "D402", # Checks for function docstrings that include the function's signature in the summary line.
    "D403", # Checks for docstrings that do not start with a capital letter.
    # "D404", #! Disagree with this rule.
    "D405", # Checks for section headers in docstrings that do not begin with capital letters.
    # "D406", #! Disagree with this rule.
    # "D407", #! Disagree with this rule.
    "D408", # Checks for section underlines in docstrings that are not on the line immediately following the section name.
    "D409", # Checks for section underlines in docstrings that do not match the length of the corresponding section header.
    "D410", # Checks for docstring sections that are not separated by a single blank line.
    "D411", # Checks for docstring sections that are not separated by a blank line.
    "D412", # Checks for docstring sections that contain blank lines between a section header and a section body.
    # "D413", #! Disagree with this rule.
    "D414", # Checks for docstrings with empty sections.
    # "D415", #! Disagree with this rule.
    "D416", # Checks for docstring section headers that do not end with a colon.
    "D417", # Checks for function docstrings that do not include documentation for all parameters in the function.
    # "D418", #! Disagree with this rule.
    "D419", # Checks for empty docstrings.
    "F401", # Checks for unused imports.
    "F402", # Checks for import bindings that are shadowed by loop variables.
    "F403", # Checks for the use of wildcard imports.
    "F404", # Checks for `__future__` imports that are not located at the beginning of a file.
    "F405", # Checks for names that might be undefined, but may also be defined in a wildcard import.
    "F406", # Check for the use of wildcard imports outside of the module namespace.
    "F407", # Checks for `__future__` imports that are not defined in the current Python version.
    "F501", # Checks for invalid `printf`-style format strings.
    "F502", # Checks for named placeholders in `printf`-style format strings without mapping-type values.
    "F503", # Checks for uses of mapping-type values in `printf`-style format strings without named placeholders.
    "F504", # Checks for unused mapping keys in `printf`-style format strings.
    "F505", # Checks for named placeholders in `printf`-style format strings that are not present in the provided mapping.
    "F506", # Checks for `printf`-style format strings that have mixed positional and named placeholders.
    "F507", # Checks for `printf`-style format strings that have a mismatch between the number of positional placeholders and the number of substitution values.
    "F508", # Checks for `printf`-style format strings that use the `*` specifier with non-tuple values.
    "F509", # Checks for `printf`-style format strings with invalid format characters.
    "F521", # Checks for `str.format` calls with invalid format strings.
    "F522", # Checks for `str.format` calls with unused keyword arguments.
    "F523", # Checks for `str.format` calls with unused positional arguments.
    "F524", # Checks for `str.format` calls with placeholders that are missing arguments.
    "F525", # Checks for `str.format` calls that mix automatic and manual numbering.
    # "F541", # Checks for f-strings that do not contain any placeholder expressions. #! Disagree with this rule.
    "F601", # Checks for dictionary literals that associate multiple values with the same key.
    "F602", # Checks for dictionary keys that are repeated with different values.
    "F621", # Checks for the use of too many expressions in starred assignment statements.
    "F622", # Checks for the use of multiple starred expressions in assignment statements.
    "F631", # Checks for `assert` statements that use non-empty tuples as test conditions.
    "F632", # Checks for `is` and `is not` comparisons against literals.
    "F633", # Checks for `print` statements that use the `>>` syntax.
    "F634", # Checks for `if` statements that use non-empty tuples as test conditions.
    "F701", # Checks for `break` statements outside of loops.
    "F702", # Checks for `continue` statements outside of loops.
    "F704", # Checks for `yield`, `yield from`, and `await` usages outside of functions.
    "F706", # Checks for `return` statements outside of functions.
    "F707", # Checks for `except` blocks that handle all exceptions, but are not the last `except` block in a `try` statement.
    "F722", # Checks for forward annotations that include invalid syntax.
    "F811", # Checks for variable definitions that redefine (or "shadow") unused variables.
    "F821", # Checks for uses of undefined names.
    "F822", # Checks for undefined names in `__all__`.
    "F823", # Checks for undefined local variables.
    "F841", # Checks for the presence of unused variables in function scopes.
    "F842", # Checks for local variables that are annotated but never used.
    "F901", # Checks for `raise` statements that raise `NotImplemented`.
    "PGH003", # Check for `type: ignore` annotations that suppress all type warnings, as opposed to targeting specific type warnings.
    "PGH004", # Check for `noqa` annotations that suppress all diagnostics, as opposed to targeting specific diagnostics.
    "PGH005", # Checks for common mistakes when using mock objects.
    "PLC0105", # Checks for type names that do not match the variance of their associated type parameter.
    "PLC0131", # Checks for `TypeVar` and `ParamSpec` definitions in which the type is both covariant and contravariant.
    "PLC0132", # Checks for `TypeVar`, `TypeVarTuple`, `ParamSpec`, and `NewType` definitions in which the name of the type parameter does not match the name of the variable to which it is assigned.
    "PLC0205", # Checks for single strings assigned to `__slots__`.
    "PLC0206", # Checks for dictionary iterations that extract the dictionary value via explicit indexing, instead of using `.items()`.
    "PLC0207", # Checks for access to the first element of `str.split()` or last element of `str.rsplit()` without `maxsplit = 1`.
    "PLC0208", # Checks for iteration over a `set` literal where each element in the set is itself a literal value.
    "PLC0414", # Checks for import aliases that do not rename the original package. This rule does not apply in `__init__.py` files.
    "PLC0415", # Checks for import statements outside of a module's top-level scope. #~ I'm sceptical of this rule.
    "PLC1802", # Checks for len calls on sequences in a boolean test context. #~ I'm sceptical of this rule.
    "PLC1901", # Checks for comparisons to empty strings.
    "PLC2401", # Checks for the use of non-ASCII characters in variable names.
    "PLC2403", # Checks for the use of non-ASCII characters in import statements.
    # "PLC2701", #! I disagree with this rule.
    "PLC2801", # Checks for explicit use of dunder methods.
    "PLC3002", # Checks for unnecessary direct calls to lambda expressions.
    "PLE0100", # Checks for `__init__` methods that are turned into generators by the inclusion of `yield` or `yield from` expressions.
    "PLE0101", # Checks for `__init__` methods that return values.
    "PLE0115", # Checks for variables which are both declared as both `nonlocal` and `global`.
    "PLE0116", # Checks for `continue` statements inside `finally`.
    "PLE0117", # Checks for `nonlocal` names without bindings.
    "PLE0118", # Checks for uses of names that are declared as `global` prior to the relevant `global` declaration.
    "PLE0237", # Checks for assignments to attributes that are not defined in `__slots__`.
    "PLE0241", # Checks for duplicate base classes in class definitions.
    "PLE0302", # Checks for "dunder" methods that have an unexpected method signature.
    "PLE0303", # Checks for `__len__` implementations that return values that are not non-negative integers.
    "PLE0304", # Checks for `__bool__` implementations that return a type other than `bool`.
    "PLE0305", # Checks for `__index__` implementations that return non-integer values.
    "PLE0307", # Checks for `__str__` implementations that return a type other than `str`.
    "PLE0308", # Checks for `__bytes__` implementations that return types other than `bytes`.
    "PLE0309", # Checks for `__hash__` implementations that return non-integer values.
    "PLE0604", # Checks for the inclusion of invalid objects in `__all__`.
    "PLE0605", # Checks for invalid assignments to `__all__`.
    "PLE0643", # Checks for hard-coded sequence accesses that are known to be out of bounds.
    "PLE0704", # Checks for bare `raise` statements outside of exception handlers.
    "PLE1132", # Checks for repeated keyword arguments in function calls.
    "PLE1141", # Checks for dictionary unpacking in a for loop without calling `.items()`.
    "PLE1142", # Checks for uses of `await` outside `async` functions.
    "PLE1205", # Checks for too many positional arguments for a `logging` format string.
    "PLE1206", # Checks for too few positional arguments for a `logging` format string.
    "PLE1300", # Checks for unsupported format types in format strings.
    "PLE1307", # Checks for mismatched argument types in "old-style" format strings.
    "PLE1310", # Checks duplicate characters in `str.strip` calls.
    "PLE1507", # Checks for `os.getenv` calls with an invalid key argument.
    "PLE1519", # Checks for methods decorated with `@singledispatch`.
    "PLE1520", # Checks for non-method functions decorated with `@singledispatchmethod`.
    "PLE1700", # Checks for uses of `yield` from in `async` functions.
    "PLE2502", # Checks for bidirectional formatting characters.
    "PLE2510", # Checks for strings that contain the control character `BS`.
    "PLE2512", # Checks for strings that contain the raw control character `SUB`.
    "PLE2513", # Checks for strings that contain the raw control character `ESC`.
    "PLE2514", # Checks for strings that contain the raw control character `NUL` (0 byte).
    "PLE2515", # Checks for strings that contain the zero width space character.
    "PLE4703", # Checks for loops in which a `set` is modified during iteration. #> Requires preview rules to be enabled.
    "PLR0124", # Checks for operations that compare a name to itself.
    "PLR0133", # Checks for comparisons between constants.
    "PLR0202", # Checks for the use of a `classmethod` being made without the decorator. #> Requires preview rules to be enabled.
    "PLR0203", # Checks for the use of a `staticmethod` being made without the decorator. #> Requires preview rules to be enabled.
    "PLR0206", # Checks for property definitions that accept function parameters.
    "PLR0402", # Checks for submodule imports that are aliased to the submodule name.
    # "PLR0904", #! I disagree with this rule.
    # "PLR0911", #! I disagree with this rule.
    # "PLR0912", #! I disagree with this rule.
    # "PLR0913", #! I disagree with this rule.
    # "PLR0914", #! I disagree with this rule.
    # "PLR0915", #! I disagree with this rule.
    # "PLR0916", #! I disagree with this rule.
    # "PLR0917", #! I disagree with this rule.
    # "PLR1702", #! I disagree with this rule.
    "PLR1704", # Checks for variables defined in `for`, `try`, `with` statements that redefine function parameters.
    "PLR1711", # Checks for functions that end with an unnecessary `return` or `return None`, and contain no other `return` statements.
    "PLR1714", # Checks for repeated equality comparisons that can be rewritten as a membership test.
    "PLR1716", # Check for chained boolean operations that can be simplified. #~ I'm sceptical of this rule.
    "PLR1722", # Checks for uses of the `exit()` and `quit()`.
    "PLR1730", # Checks for `if` statements that can be replaced with `min()` or `max()` calls. #~ I'm sceptical of this rule.
    "PLR1733", # Checks for key-based dict accesses during `.items()` iterations.
    "PLR1736", # Checks for index-based list accesses during `enumerate` iterations.
    "PLR2004", # Checks for the use of unnamed numerical constants ("magic") values in comparisons.
    "PLR2044", # Checks for a # symbol appearing on a line not followed by an actual comment.
    "PLR5501", # Checks for `else` blocks that consist of a single `if` statement. #~ I'm sceptical of this rule.
    "PLR6104", # Checks for assignments that can be replaced with augmented assignment statements.
    "PLR6201", # Checks for membership tests on `list` and `tuple` literals.
    "PLR6301", # Checks for the presence of unused `self` parameter in methods definitions.
    "PLW0108", # Checks for `lambda` definitions that consist of a single function call with the same arguments as the `lambda` itself. #~ I'm sceptical of this rule. #> Requires preview rules to be enabled.
    "PLW0120", # Checks for `else` clauses on loops without a `break` statement.
    "PLW0127", # Checks for self-assignment of variables.
    "PLW0128", # Checks for declared assignments to the same variable multiple times in the same assignment.
    "PLW0129", # Checks for `assert` statements that use a string literal as the first argument.
    "PLW0131", # Checks for uses of named expressions that can be replaced by regular assignment statements.
    "PLW0133", # Checks for an exception that is not raised.
    "PLW0177", # Checks for comparisons against NaN values.
    "PLW0211", # Checks for static methods that use `self` or `cls` as their first argument. This rule also applies to `__new__` methods, which are implicitly static.
    "PLW0244", # Checks for a re-defined slot in a subclass. #> Requires preview rules to be enabled.
    "PLW0245", # Detects attempts to use `super` without parentheses.
    "PLW0406", # Checks for import statements that import the current module.
    "PLW0602", # Checks for `global` variables that are not assigned a value in the current scope.
    "PLW0603", # Checks for the use of `global` statements to update identifiers.
    "PLW0604", # Checks for uses of the `global` keyword at the module level.
    "PLW0642", # Checks for assignment of `self` and `cls` in instance and class methods respectively.
    "PLW0711", # Checks for `except` clauses that attempt to catch multiple exceptions with a binary operation (`and` or `or`).
    "PLW1501", # Check for an invalid `mode` argument in `open` calls.
    "PLW1507", # Check for shallow `os.environ` copies.
    "PLW1508", # Checks for `os.getenv` calls with invalid default values.
    "PLW1509", # Checks for uses of `subprocess.Popen` with a `preexec_fn` argument.
    "PLW1510", # Checks for uses of `subprocess.run` without an explicit `check` argument.
    "PLW1514", # Checks for uses of `open` and related calls without an explicit `encoding` argument. #> Requires preview rules to be enabled.
    "PLW1641", # Checks for classes that implement `__eq__` but not `__hash__`.
    "PLW2101", # Checks for lock objects that are created and immediately discarded in `with` statements.
    "PLW2901", # Checks for variables defined in `for` loops and `with` statements that get overwritten within the body.
    "PLW3201", # Checks for dunder methods that have no special meaning in Python 3.
    # "PLW3301", # Checks for nested `min` and `max` calls. #! Should not be done, but the rule produces false positives.
    "UP001", # Checks for the use of `__metaclass__ = type` in class definitions.
    "UP003", # Checks for uses of `type` that take a primitive as an argument.
    "UP004", # Checks for classes that inherit from `object`.
    "UP005", # Checks for uses of deprecated methods from the `unittest` module.
    "UP006", # Checks for the use of generics that can be replaced with standard library variants based on PEP 585.
    "UP007", # Check for type annotations that can be rewritten based on PEP 604 syntax.
    "UP008", # Checks for `super` calls that pass redundant arguments.
    "UP009", # Checks for unnecessary UTF-8 encoding declarations.
    "UP010", # Checks for unnecessary `__future__` imports.
    "UP011", # Checks for unnecessary parentheses on `functools.lru_cache` decorators.
    # "UP012", #! I disagree with this rule.
    "UP013", # Checks for `TypedDict` declarations that use functional syntax. #~ I'm sceptical of this rule.
    "UP014", # Checks for `NamedTuple` declarations that use functional syntax. #~ I'm sceptical of this rule.
    # "UP015", #! I disagree with this rule.
    "UP017", # Checks for uses of `datetime.timezone.utc`.
    "UP018", # Checks for unnecessary calls to `str`, `bytes`, `int`, `float`, and `bool`.
    "UP019", # Checks for uses of `typing.Text`.
    "UP020", # Checks for uses of `io.open`.
    "UP021", # Checks for uses of `subprocess.run` that set the `universal_newlines` keyword argument.
    "UP022", # Checks for uses of subprocess.run that send `stdout` and `stderr` to a pipe.
    "UP023", # Checks for uses of the `xml.etree.cElementTree` module.
    "UP024", # Checks for uses of exceptions that alias `OSError`. #~ I'm sceptical of this rule.
    "UP025", # Checks for uses of the Unicode kind prefix (`u`) in strings.
    "UP026", # Checks for imports of the `mock` module that should be replaced with `unittest.mock`.
    "UP028", # Checks for `for` loops that can be replaced with `yield from` expressions.
    "UP029", # Checks for unnecessary imports of builtins.
    "UP030", # Checks for unnecessary positional indices in format strings.
    "UP031", # Checks for `printf`-style string formatting, and offers to replace it with `str.format` calls.
    "UP032", # Checks for `str.format` calls that can be replaced with f-strings.
    "UP033", # Checks for uses of `functools.lru_cache` that set `maxsize = None`.
    "UP034", # Checks for extraneous parentheses.
    "UP035", # Checks for uses of deprecated imports based on the minimum supported Python version.
    "UP036", # Checks for conditional blocks gated on `sys.version_info` comparisons that are outdated for the minimum supported Python version.
    "UP037", # Checks for the presence of unnecessary quotes in type annotations.
    "UP039", # Checks for class definitions that include unnecessary parentheses after the class name.
    "UP040", # Checks for use of `TypeAlias` annotations and `TypeAliasType` assignments for declaring type aliases.
    "UP041", # Checks for uses of exceptions that alias `TimeoutError`.
    "UP042", # Checks for classes that inherit from both `str` and `enum.Enum`. #> Requires preview rules to be enabled.
    "UP043", # Checks for unnecessary default type arguments for `Generator` and `AsyncGenerator` on Python 3.13+.
    "UP044", # Checks for uses of `Unpack[]` on Python 3.11 and above, and suggests using `*` instead.
    "UP045", # Checks for `typing.Optional` annotations that can be rewritten based on PEP 604 syntax.
    "UP046", # Checks for use of standalone type variables and parameter specifications in generic classes.
    "UP047", # Checks for use of standalone type variables and parameter specifications in generic functions.
    "UP049", # Checks for use of PEP 695 type parameters with leading underscores in generic classes and functions.
    "UP050", # Checks for `metaclass = type` in class definitions.
    "FURB101", # Checks for uses of `open` and `read` that can be replaced by `pathlib` methods. #~ I'm sceptical of this rule. #> Requires preview rules to be enabled.
    "FURB103", # Checks for uses of `open` and `write` that can be replaced by `pathlib` methods. #~ I'm sceptical of this rule. #> Requires preview rules to be enabled.
    "FURB105", # Checks for `print` calls with unnecessary empty strings as positional arguments and unnecessary `sep` keyword arguments.
    # "FURB110", #! I disagree with this rule.
    "FURB113", # Checks for consecutive calls to `append`. #> Requires preview rules to be enabled.
    "FURB116", # Checks for uses of `bin(...)[2:]` (or `hex`, or `oct`) to convert an integer into a string.
    # "FURB118", #! I disagree with this rule.
    "FURB122", # Checks for the use of `IOBase.write` in a `for` loop.
    "FURB129", # Checks for uses of `readlines()` when iterating over a file line-by-line.
    "FURB131", # Checks for `del` statements that delete the entire slice of a list or dictionary. #~ I'm sceptical of this rule.
    # "FURB132", # Checks for uses of `set.remove` that can be replaced with `set.discard`. #! Rule produces false negatives.
    "FURB136", # Checks for `if` expressions that can be replaced with `min()` or `max()` calls. #> Requires preview rules to be enabled.
    # "FURB140", #! I disagree with this rule.
    "FURB142", # Checks for code that updates a `set` with the contents of an iterable by using a `for` loop to call `.add()` or `.discard()` on each element separately. #> Requires preview rules to be enabled.
    "FURB145", # Checks for unbounded slice expressions to copy a list. #> Requires preview rules to be enabled.
    "FURB148", # Checks for uses of `enumerate` that discard either the index or the value when iterating over a sequence. #> Requires preview rules to be enabled.
    "FURB152", # Checks for literals that are similar to constants in `math` module. #> Requires preview rules to be enabled.
    "FURB154", # Checks for consecutive `global` (or `nonlocal`) statements. #> Requires preview rules to be enabled.
    "FURB156", # Checks for uses of hardcoded charsets, which are defined in Python string module. #> Requires preview rules to be enabled.
    "FURB157", # Checks for unnecessary string literal or float casts in `Decimal` constructors.
    "FURB161", # Checks for uses of `bin(...).count("1")` to perform a population count.
    "FURB162", # Checks for `datetime.fromisoformat()` calls where the only argument is an inline replacement of `Z` with a zero offset timezone.
    # "FURB163", # #! I disagree with this rule because Python does not follow math notation for this.
    "FURB164", # Checks for unnecessary `from_float` and `from_decimal` usages to construct `Decimal` and `Fraction` instances. #> Requires preview rules to be enabled.
    "FURB166", # Checks for uses of `int` with an explicit base in which a string expression is stripped of its leading prefix (i.e., 0b, 0o, or 0x).
    "FURB167", # Checks for the use of shorthand aliases for regular expression flags.
    "FURB168", # Checks for uses of `isinstance` that check if an object is of type `None`.
    "FURB169", # Checks for uses of `type` that compare the type of an object to the type of `None`.
    "FURB171", # Checks for membership tests against single-item containers.
    "FURB177", # Checks for current-directory lookups using `Path().resolve()`.
    "FURB180", # Checks for uses of `metaclass = abc.ABCMeta` to define abstract base classes (ABCs).
    "FURB181", # Checks for the use of `.digest().hex()` on a hashlib hash, like `sha512`.
    "FURB187", # Checks for list reversals that can be performed in-place in lieu of creating a new list.
    "FURB188", # Checks for code that could be written more idiomatically using `str.removeprefix()` or `str.removesuffix()`. #~ I'm sceptical of this rule.
    "FURB189", # Checks for subclasses of `dict`, `list` or `str`.
    "FURB192", # Checks for uses of `sorted()` to retrieve the minimum or maximum value in a sequence.
    "RUF001", # Checks for ambiguous Unicode characters in strings.
    "RUF002", # Checks for ambiguous Unicode characters in docstrings.
    "RUF003", # Checks for ambiguous Unicode characters in comments.
    "RUF005", # Checks for uses of the `+` operator to concatenate collections.
    "RUF006", # Checks for `asyncio.create_task` and `asyncio.ensure_future` calls that do not store a reference to the returned result.
    "RUF007", # Checks for use of `zip()` to iterate over successive pairs of elements.
    "RUF008", # Checks for mutable default values in dataclass attributes.
    "RUF009", # Checks for function calls in dataclass attribute defaults.
    "RUF010", # Checks for uses of `str()`, `repr()`, and `ascii()` as explicit type conversions within f-strings.
    "RUF012", # Checks for mutable default values in class attributes.
    "RUF013", # Checks for the use of implicit `Optional` in type annotations when the default parameter value is `None`.
    "RUF015", # Checks for constructs that can be replaced with `next(iter(...))`.
    "RUF016", # Checks for indexed access to lists, strings, tuples, bytes, and comprehensions using a type other than an integer or slice.
    "RUF017", # Checks for the use of `sum()` to flatten lists of lists, which has quadratic complexity.
    "RUF018", # Checks for named assignment expressions in assert statements.
    "RUF019", # Checks for unnecessary key checks prior to accessing a dictionary.
    "RUF020", # Checks for uses of `typing.NoReturn` and `typing.Never` in union types.
    "RUF021", # Checks for chained operators where adding parentheses could improve the clarity of the code.
    # "RUF022", #! I disagree with this rule.
    # "RUF023", #! I disagree with this rule.
    "RUF024", # Checks for mutable objects passed as a value argument to `dict.fromkeys`.
    "RUF026", # Checks for incorrect usages of `default_factory` as a keyword argument when initializing a `defaultdict`.
    "RUF027", # Searches for strings that look like they were meant to be f-strings, but are missing an f prefix. #~ Could be problematical with Jinja. #> Requires preview rules to be enabled.
    "RUF028", # Checks for formatter suppression comments that are ineffective or incompatible with Ruff's formatter.
    "RUF029", # Checks for functions declared `async` that do not await or otherwise use features requiring the function to be declared `async`. #> Requires preview rules to be enabled.
    "RUF030", # Checks for uses of `assert expression, print(message)`.
    "RUF031", # Checks for consistent style regarding whether nonempty tuples in subscripts are parenthesized. #> Requires preview rules to be enabled.
    "RUF032", # Checks for `Decimal` calls passing a `float` literal.
    "RUF033", # Checks for `__post_init__` dataclass methods with parameter defaults.
    "RUF034", # Checks for useless `if-else` conditions with identical arms.
    "RUF036", # Checks for type annotations where `None` is not at the end of an union. #> Requires preview rules to be enabled.
    "RUF037", # Checks for usages of `collections.deque` that have an empty iterable as the first argument. #> Requires preview rules to be enabled.
    "RUF038", # Checks for `Literal[True, False]` type annotations. #> Requires preview rules to be enabled.
    "RUF039", # Checks for `re` and `regex` calls where the first argument is not a raw string. #> Requires preview rules to be enabled.
    "RUF040", # Checks for `assert` messages where a non-string literal was likely intended to be used in a comparison assertion, rather than as a message.
    "RUF041", # Checks for unnecessary nested `Literal`.
    "RUF043", # Checks for non-raw literal string arguments passed to the `match` parameter of `pytest.raises()` where the string contains at least one unescaped regex metacharacter.
    "RUF045", # Checks for implicit class variables in dataclasses. #> Requires preview rules to be enabled.
    "RUF046", # Checks for `int` conversions of values that are already integers.
    "RUF047", # Checks for `else` clauses that only contain `pass` or `...` statements.
    "RUF048", # Checks for calls of the form `map(int, __version__.split("."))`.
    "RUF049", # Checks for `enum` classes which are also decorated with `@dataclass`.
    "RUF051", # Checks for `if key in dictionary: del dictionary[key]`.
    "RUF052", # Checks for "dummy variables" that are in fact used. #> Requires preview rules to be enabled.
    "RUF053", # Checks for classes that have PEP 695 while also inheriting from `typing.Generic` or `typing_extensions.Generic`.
    "RUF054", # Checks for form feed characters preceded by either a space or a tab. #> Requires preview rules to be enabled.
    "RUF055", # Checks for uses of the `re` module that can be replaced with builtin `str` methods. #> Requires preview rules to be enabled. #~ I'm sceptical of this rule.
    # "RUF056", #! I disagree with this rule.
    "RUF057", # Checks for `round()` calls that have no effect on the input. #~ I'm sceptical of this rule.
    "RUF058", # Checks for `itertools.starmap` calls where the second argument is a `zip` call.
    "RUF059", # Checks for the presence of unused variables in unpacked assignments. #~ I'm sceptical of this rule.
    "RUF060", # Checks for membership tests on empty collections. #> Requires preview rules to be enabled.
    "RUF061", # Checks for non-contextmanager use of `pytest.raises`, `pytest.warns`, and `pytest.deprecated_call`. #> Requires preview rules to be enabled.
    "RUF063", # Checks for access of dict annotations. #> Requires preview rules to be enabled.
    "RUF064", # Checks for standard library functions which take a numeric `mode` argument where a non-octal integer literal is passed. #> Requires preview rules to be enabled.
    "RUF100", # Checks for `noqa` directives that are no longer applicable.
    "RUF101", # Checks for `noqa` directives that use redirected rule codes.
    "RUF102", # Checks for `noqa` codes that are invalid.
    "RUF200", # Checks for any `pyproject.toml` that does not conform to the schema from the relevant PEPs. #~ I'm sceptical of this rule.
    "TRY002", # Checks for code that raises `Exception` or `BaseException` directly.
    # "TRY003", #! I disagree with this rule.
    "TRY004", # Checks for type checks that do not raise `TypeError`.
    # "TRY201", #! I disagree with this rule.
    # "TRY203", #! I disagree with this rule.
    "TRY300", # Checks for `return` statements in `try` blocks.
    "TRY301", # Checks for `raise` statements within `try` blocks.
    "TRY400", # Checks for uses of `logging.error` instead of `logging.exception` when logging an exception.
    "TRY401", # Checks for excessive logging of exception objects.
]

# Typing modules
typing-modules = []

# Enable `from __future__ import annotations` imports
future-annotations = true


[tool.ruff.lint.flake8-bugbear]
extend-immutable-calls = []


[tool.ruff.lint.flake8-boolean-trap]
extend-allowed-calls = []


[tool.ruff.lint.flake8-import-conventions.extend-aliases]
# Ruff already has several aliases by default: https://docs.astral.sh/ruff/settings/#lint_flake8-import-conventions_aliases
# Declare additional aliases here.


[tool.ruff.lint.flake8-pytest-style]
fixture-parentheses = false
mark-parentheses = false
parametrize-names-type = "tuple"
parametrize-values-type = "list"
parametrize-values-row-type = "tuple"
raises-extend-require-match-for = []
warns-extend-require-match-for = []


[tool.ruff.lint.flake8-quotes]
docstring-quotes = "double"
inline-quotes = "double"
multiline-quotes = "double"


[tool.ruff.lint.flake8-tidy-imports]
ban-relative-imports = "parents"

# These modules need to be added on a project-basis.
banned-module-level-imports = []


[tool.ruff.lint.flake8-tidy-imports.banned-api]
# Overtime, I will be completing this with deprecated APIs.
# "cgi".msg = "The cgi module is deprecated, see https://peps.python.org/pep-0594/#cgi."
# "typing.TypedDict".msg = "Use typing_extensions.TypedDict instead."


[tool.ruff.lint.flake8-type-checking]
# Add quotes around type annotations, if doing so would allow an import to be moved into a type-checking block.
quote-annotations = true
runtime-evaluated-base-classes = []
runtime-evaluated-decorators = []


[tool.ruff.lint.isort]
case-sensitive = false
combine-as-imports = false
force-sort-within-sections = false
force-single-line = false
from-first = false
length-sort = false
length-sort-straight = false
lines-after-imports = 2
lines-between-types = 0
order-by-type = true
section-order = ["future", "standard-library", "third-party", "first-party", "local-folder", "testing"]
default-section = "third-party"

classes = []
constants = []
extra-standard-library = []
required-imports = []


[tool.ruff.lint.isort.sections]
testing = ["pytest", "hypothesis", "unittest"]


[tool.ruff.lint.mccabe]
# Flag errors (`C901`) whenever the complexity level exceeds 10.
max-complexity = 10


[tool.ruff.lint.pep8-naming]
extend-ignore-names = []


[tool.ruff.lint.pycodestyle]
max-doc-length = 120
max-line-length = 120
ignore-overlong-task-comments = false


[tool.ruff.lint.pydocstyle]
ignore-var-parameters = true


[tool.ruff.lint.pylint]
allow-magic-value-types = ["str", "bytes"]

# Extende list of dunder methods by adding more here.
allow-dunder-method-names = []
