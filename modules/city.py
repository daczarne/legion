from dataclasses import dataclass, field
from typing import Any, TypedDict, ClassVar

from modules.buildings import RssCollection

from .buildings import Building, BUILDINGS, BuildingsCount

@dataclass
class ResourcesPotential:
    food: int = 0
    ore: int = 0
    wood: int = 0


@dataclass
class CityBuildings:
    buildings: BuildingsCount = field(default_factory = dict)
    
    MAX_NUMBER_OF_BUILDINGS_PER_CITY: ClassVar[int] = 9
    
    def __post_init__(self) -> None:
        # Ensure city_hall is always present
        if "city_hall" not in self.buildings:
            self.buildings["city_hall"] = 1
        
        unknown: set[str] = set(self.buildings) - BUILDINGS.keys()
        if unknown:
            raise ValueError(f"Unknown building(s): {', '.join(unknown)}")
        
        total: int = sum(self.buildings.values())
        if total > self.MAX_NUMBER_OF_BUILDINGS_PER_CITY:
            raise ValueError(f"Too many buildings: {total} (max allowed is {self.MAX_NUMBER_OF_BUILDINGS_PER_CITY})")
    
    def get_count(self, name: str) -> int:
        return self.buildings.get(name, 0)


@dataclass
class City:
    campaign: str
    name: str
    resource_potentials: ResourcesPotential
    buildings: CityBuildings
    
    base_production: RssCollection | None = field(init = False)
    
    RSS_BASE_PRODUCTIVITY_PER_WORKER: ClassVar[int] = 12
    MAX_WORKERS: ClassVar[int] = 18
    
    #~ Methods to add:
    
    #* Validate city buildings
    # Validations need to include the following situations.
    # 
    # Rss buildings are allowed. This is because a city with, for example, rss potential of 0 for food, cannot create
    # food-producing buildings (like farms, vinyards, or fishing villages), even if it has a lake (the lake is, sadly,
    # a waisted building spot in this case).
    # 
    # Guilds. Building guilds requires the production building itself. For example, if there are no farms, there can be
    # no farmers guild. Similarly, if there are no lumber mills, there can be no carpenters guild, and so on.
    #
    # Additionally, there are other dependencies between buildings. For example, a city needs:
    #   farm or vinyard => stables
    #   lumber mill => fletcher
    #   mine (not outcrop or mountain) => blacksmith
    #   fort => quartermaster
    #   training grounds => other training facilities (like gladiator school, imperial residence, bordello)
    #
    # But, all dependencies can be bypassed by building the required building (e.g. a farm), then building the 
    # dependent building (e.g. stables), and then deleting the required building and using that spot to build something
    # else. Some of these dependencies makes sense to validate them because the dependent building makes no sense
    # without the dependency building. For example, no sense in having a city with a farmers guild, if the city has no
    # farms.
    #
    # Lastly, not all cities can accept all potential building scenarios. For example, a city with a lake and enough
    # food potential for a fishing village, "cannot" build 6 mines. Since there are only a maximum of 18 workers per
    # city, this configuration (1 fishing village + 6 mines) would mean that at least one of the buildings is not
    # staffed (potentially, even empty). The validation should warn agains this scenario.
    
    #* Calculate base production
    def _calculate_base_production(self) -> RssCollection:
        # This method uses the city buildings and the city production potentials to calculate the base production for
        # each rss (before bonuses generated by buildings).
        # Formula:
        #   base_prod_per_worker = int(floor(prod_potential * BUILDINGS.prod_per_worker / 100.0))
        #   base_production = qty_buildings * max_workers * prod_per_worker
        #   base_production_food = qty_food_buildings * prod_per_worker_food * max_workers
        from math import floor
        
        base_production: RssCollection = RssCollection()
        
        for building, qty_buildings in self.buildings.buildings.items():
            
            production_per_worker: RssCollection = BUILDINGS[building]["productivity_per_worker"]
            max_workers: int = BUILDINGS[building]["max_workers"]
            
            # Production per worker
            prod_per_worker_food: int = int(floor(production_per_worker.food * self.resource_potentials.food / 100.0))
            prod_per_worker_ore: int = int(floor(production_per_worker.ore * self.resource_potentials.ore / 100.0))
            prod_per_worker_wood: int = int(floor(production_per_worker.wood * self.resource_potentials.wood / 100.0))
            
            # Base production
            base_production_food: int = prod_per_worker_food * qty_buildings * max_workers
            base_production_ore: int = prod_per_worker_ore * qty_buildings * max_workers
            base_production_wood: int = prod_per_worker_wood * qty_buildings * max_workers
            
            base_production.food = base_production.food + base_production_food
            base_production.ore = base_production.ore + base_production_ore
            base_production.wood = base_production.wood + base_production_wood
        
        return base_production
    
    #* Calculate production bonuses
    # This method should take the buildings and calculate the production multipliers. It
    # should return a dictionary with the multiplier for each of food, ore, and wood. This
    # should be a post init attr.
    
    #* Calculate production
    # This should take the resource_potentials, the production multipliers, and
    # the buldings and return a dict with the production for food, ore, and wood.
    # This should be a post init attr.
    
    #* Calculate maintenance costs
    # This method should take the buildings information and calculate the maintenance cost
    # for each rss. It should return a dict with the maintenance cost for food, ore, and wood.
    # This should be a post init. Once the buildings are supplied by the user, the maintenance
    # cost of the city is determined by them.
    
    #* Calculate totals
    # This method should calculate the "profits" for each rss. Formula:
    #   floor(base_production * (1 + production_bonus / 100) - maintenance_costs))
    
    def __post_init__(self) -> None:
        self.base_production = self._calculate_base_production()

    #* Display results
    def _display_city_information(self) -> None:
        print(f"Campaign: {self.campaign} - City: {self.name}")
        print()
    
    def _display_city_buildings(self) -> None:
        # This method should display the results in the terminal
        print(f"--------------")
        print(f"City buildings")
        print(f"--------------")
        
        for building, qty in self.buildings.buildings.items():
            print(f"  - {building.replace('_', ' ').capitalize()} ({qty})")
    
    def _display_city_production(self) -> None:
        col_headers: list[str] = [
            "Resource",
            "Rss. pot.",
            "Prod.",
            "Bonus",
            "Maintenance",
            "Total"
        ]
        table_header: str = "| " + " | ".join(col_headers) + " |"
        horizontal_rule: str = "-" * len(table_header)
        
        # Table header row
        print(horizontal_rule)
        print(table_header)
        print(horizontal_rule)
        
        # Food row
        prod_pot: str = str(self.resource_potentials.food)
        # base_prod, prod_bonus, maintenance, total = production_table.get("food", {}).values()
        print(
            f"| Food{' ' * 4} "
            f"| {' ' * (len(col_headers[1]) - len(prod_pot))}{prod_pot} "
            # f"| {' ' * (len(col_headers[2]) - len(str(base_prod)))}{base_prod} "
            # f"| {' ' * (len(col_headers[3]) - len(str(prod_bonus)))}{prod_bonus} "
            # f"| {' ' * (len(col_headers[4]) - len(str(maintenance)))}{maintenance} "
            # f"| {' ' * (len(col_headers[5]) - len(str(total)))}{total} |"
        )
        
        # Ore row
        prod_pot: str = str(self.resource_potentials.ore)
        # base_prod, prod_bonus, maintenance, total = production_table.get("ore", {}).values()
        print(
            f"| Ore{' ' * 5} "
            f"| {' ' * (len(col_headers[1]) - len(prod_pot))}{prod_pot} "
            # f"| {' ' * (len(col_headers[2]) - len(str(base_prod)))}{base_prod} "
            # f"| {' ' * (len(col_headers[3]) - len(str(prod_bonus)))}{prod_bonus} "
            # f"| {' ' * (len(col_headers[4]) - len(str(maintenance)))}{maintenance} "
            # f"| {' ' * (len(col_headers[5]) - len(str(total)))}{total} |"
        )
        
        #* Wood row
        prod_pot: str = str(self.resource_potentials.wood)
        # base_prod, prod_bonus, maintenance, total = production_table.get("wood", {}).values()
        print(
            f"| Wood{' ' * 4} "
            f"| {' ' * (len(col_headers[1]) - len(prod_pot))}{prod_pot} "
            # f"| {' ' * (len(col_headers[2]) - len(str(base_prod)))}{base_prod} "
            # f"| {' ' * (len(col_headers[3]) - len(str(prod_bonus)))}{prod_bonus} "
            # f"| {' ' * (len(col_headers[4]) - len(str(maintenance)))}{maintenance} "
            # f"| {' ' * (len(col_headers[5]) - len(str(total)))}{total} |"
        )
        
        #* Bottom horizontal row
        print(horizontal_rule)
    
    
    def display_results(self, include_city_information: bool = False) -> None:
        if include_city_information:
            self._display_city_information()
        
        self._display_city_buildings()
        
        print()
        
        self._display_city_production()
