from dataclasses import dataclass, field
from typing import TypedDict, ClassVar

from .buildings import Building, BUILDINGS


class ResourcesPotential(TypedDict):
    food: int
    ore: int
    wood: int


@dataclass
class CityBuildings:
    buildings: dict[str, int] = field(default_factory = dict)
    
    MAX_NUMBER_OF_BUILDINGS_PER_CITY: ClassVar[int] = 9
    
    def __post_init__(self) -> None:
        # Ensure city_hall is always present
        if "city_hall" not in self.buildings:
            self.buildings["city_hall"] = 1
        
        unknown: set[str] = set(self.buildings) - BUILDINGS.keys()
        if unknown:
            raise ValueError(f"Unknown building(s): {', '.join(unknown)}")
        
        total: int = sum(self.buildings.values())
        if total > self.MAX_NUMBER_OF_BUILDINGS_PER_CITY:
            raise ValueError(f"Too many buildings: {total} (max allowed is {self.MAX_NUMBER_OF_BUILDINGS_PER_CITY})")
    
    def get_count(self, name: str) -> int:
        return self.buildings.get(name, 0)
    
    def get_all_counts(self) -> dict[str, int]:
        return {name: self.buildings.get(name, 0) for name in BUILDINGS.keys()}


@dataclass
class City:
    campaign: str
    name: str
    resource_potentials: ResourcesPotential
    buildings: CityBuildings
    
    RSS_BASE_PRODUCTIVITY_PER_WORKER: ClassVar[int] = 12
    
    #~ Methods to add:
    
    #* Validate city buildings
    # This method should validate the city buildings. This is because a city with, for example, rss potential
    # of 0 for food, cannot create food-producing buildings (like farms, vinyards, or fishing villages), even if it
    # has a lake (the lake is, sadly, a waisted building spot in this case). Additionally, if there are no farms, there
    # can be no farmers guild. Similarly, if there are no lumber mills, there can be no carpenters guild, and so on.
    
    #* Create buildings from dict
    # This method should take a dict supplied by the user. The dict keys will be the building
    # name, and the value the quantity of that building. This method should add the city_hall.
    # {
    #     "farm": 6,
    #     "blacksmith": 1,
    # }
    
    #* Calculate base production
    # This method should take the city buildings and the city production potentials and
    # calculate the base production (before bonuses generated by buildings) for each rss.
    # Formula:
    #   workers = BUILDINGS.get(building, {}).get("max_workers", {}) * qty_buildings
    #   prod_per_worker = int(floor(city_prod_potential * building_prod_per_worker / 100.0))
    #   base_production_food = qty_food_buildings * prod_per_worker_food * max_workers
    
    #* Calculate production bonuses
    # This method should take the buildings and calculate the production multipliers. It
    # should return a dictionary with the multiplier for each of food, ore, and wood. This
    # should be a post init attr.
    
    #* Calculate production
    # This should take the resource_potentials, the production multipliers, and
    # the buldings and return a dict with the production for food, ore, and wood.
    # This should be a post init attr.
    
    #* Calculate maintenance costs
    # This method should take the buildings information and calculate the maintenance cost
    # for each rss. It should return a dict with the maintenance cost for food, ore, and wood.
    # This should be a post init. Once the buildings are supplied by the user, the maintenance
    # cost of the city is determined by them.
    
    #* Calculate totals
    # This method should calculate the "profits" for each rss. Formula:
    #   floor(base_production * (1 + production_bonus / 100) - maintenance_costs))
    
    #* Display results
    # This method should display the results in the terminal
